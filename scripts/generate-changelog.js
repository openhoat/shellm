#!/usr/bin/env node

/**
 * Script to generate CHANGELOG.md from Git commit history.
 *
 * Analyzes Git history and generates a CHANGELOG.md following the project's
 * task_format.md conventions with emoji tags and time-based grouping.
 *
 * Format: **[HH:MM:SS] Emoji [TAG]** Description
 * Grouped by year (### YYYY) and day (#### DD/MM)
 */

const { execSync } = require('node:child_process')
const fs = require('node:fs')
const path = require('node:path')

const CHANGELOG_PATH = path.join(process.cwd(), 'CHANGELOG.md')

// Mapping from conventional commit type to CHANGELOG emoji and tag
const TYPE_MAP = {
  feat: { emoji: 'âœ¨', tag: 'FEAT' },
  fix: { emoji: 'ðŸ›', tag: 'FIX' },
  refactor: { emoji: 'â™»ï¸', tag: 'REFACTOR' },
  perf: { emoji: 'âš¡', tag: 'PERF' },
  docs: { emoji: 'ðŸ“', tag: 'DOCS' },
  style: { emoji: 'ðŸŽ¨', tag: 'STYLE' },
  test: { emoji: 'âœ…', tag: 'TEST' },
  chore: { emoji: 'ðŸ”§', tag: 'CHORE' },
  revert: { emoji: 'âª', tag: 'REVERT' },
}

/**
 * Execute a Git command and return the result
 */
function execGit(command) {
  try {
    return execSync(command, { encoding: 'utf-8', cwd: process.cwd() })
  } catch (_error) {
    return ''
  }
}

/**
 * Get the latest git tag (semantic version tag).
 * Returns null if no tags exist.
 */
function getLatestTag() {
  const tag = execGit('git describe --tags --abbrev=0').trim()
  return tag || null
}

/**
 * Retrieve commits from Git history since the latest tag (or all if no tag exists).
 * Uses NUL (%x00) as record separator and SOH (%x01) as field separator
 * to handle multi-line commit bodies safely.
 */
function getCommits(sinceTag) {
  const range = sinceTag ? `${sinceTag}..HEAD` : ''
  const output = execGit(`git log ${range} --pretty=format:"%H%x01%s%x01%ci%x00" --reverse`)

  if (!output.trim()) return []

  return output
    .split('\0')
    .filter(entry => entry.trim() !== '')
    .map(entry => {
      const parts = entry.split('\x01')
      const hash = (parts[0] || '').trim()
      const subject = (parts[1] || '').trim()
      const dateStr = (parts[2] || '').trim()
      if (!hash || !subject || !dateStr) return null
      return { hash, subject, date: new Date(dateStr) }
    })
    .filter(Boolean)
}

/**
 * Parse a conventional commit subject line.
 * Supports: type: description, type(scope): description
 */
function parseConventionalCommit(subject) {
  const match = subject.match(/^(\w+)(?:\([^)]*\))?:\s*(.+)/)
  if (!match) return null

  const type = match[1].toLowerCase()
  const description = match[2].trim()
  const typeInfo = TYPE_MAP[type]

  if (!typeInfo) return null

  // Capitalize first letter of description
  const capitalizedDesc = description.charAt(0).toUpperCase() + description.slice(1)

  return {
    emoji: typeInfo.emoji,
    tag: typeInfo.tag,
    description: capitalizedDesc,
  }
}

/**
 * Format a Date to HH:MM:SS
 */
function formatTime(date) {
  const h = String(date.getHours()).padStart(2, '0')
  const m = String(date.getMinutes()).padStart(2, '0')
  const s = String(date.getSeconds()).padStart(2, '0')
  return `${h}:${m}:${s}`
}

/**
 * Format a Date to DD/MM
 */
function formatDay(date) {
  const d = String(date.getDate()).padStart(2, '0')
  const mo = String(date.getMonth() + 1).padStart(2, '0')
  return `${d}/${mo}`
}

/**
 * Generate the complete CHANGELOG content from Git history since the latest tag.
 * Groups commits by year and day in reverse chronological order.
 */
function generateChangelog() {
  const latestTag = getLatestTag()
  const commits = getCommits(latestTag)

  // Group commits by year then day
  const grouped = {}

  for (const commit of commits) {
    const parsed = parseConventionalCommit(commit.subject)
    if (!parsed) continue

    const year = commit.date.getFullYear()
    const day = formatDay(commit.date)
    const time = formatTime(commit.date)

    if (!grouped[year]) grouped[year] = {}
    if (!grouped[year][day]) grouped[year][day] = []

    grouped[year][day].push({
      time,
      emoji: parsed.emoji,
      tag: parsed.tag,
      description: parsed.description,
    })
  }

  // Build output in reverse chronological order
  const lines = []
  lines.push('# History')
  lines.push('')
  if (latestTag) {
    lines.push(
      `This file is automatically generated from Git commit history since **${latestTag}**.`
    )
  } else {
    lines.push('This file is automatically generated from Git commit history.')
  }
  lines.push('')
  lines.push('To view the complete history, use: `git log`')
  lines.push('')
  lines.push('## Modification History')

  const years = Object.keys(grouped).sort((a, b) => Number(b) - Number(a))

  for (const year of years) {
    lines.push('')
    lines.push(`### ${year}`)

    // Sort days reverse chronologically (compare month first, then day)
    const days = Object.keys(grouped[year]).sort((a, b) => {
      const [dA, mA] = a.split('/').map(Number)
      const [dB, mB] = b.split('/').map(Number)
      if (mA !== mB) return mB - mA
      return dB - dA
    })

    for (const day of days) {
      lines.push('')
      lines.push(`#### ${day}`)
      lines.push('')

      // Sort entries within a day reverse chronologically (latest first)
      const entries = grouped[year][day].sort((a, b) => b.time.localeCompare(a.time))

      for (const entry of entries) {
        lines.push(`- **[${entry.time}] ${entry.emoji} [${entry.tag}]** ${entry.description}`)
      }
    }
  }

  lines.push('')
  return lines.join('\n')
}

/**
 * Main entry point
 */
function main() {
  // biome-ignore lint/suspicious/noConsole: Script CLI - logging progress
  console.log('Generating CHANGELOG.md from Git history...')

  try {
    const changelog = generateChangelog()
    fs.writeFileSync(CHANGELOG_PATH, changelog, 'utf-8')
    // biome-ignore lint/suspicious/noConsole: Script CLI - logging success
    console.log('CHANGELOG.md generated successfully')
  } catch (error) {
    // biome-ignore lint/suspicious/noConsole: Script CLI - logging errors
    console.error('Error generating CHANGELOG:', error.message)
    process.exit(1)
  }
}

if (require.main === module) {
  main()
}

module.exports = { generateChangelog, getLatestTag }
